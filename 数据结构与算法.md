# 数据结构与算法

> 本学习笔记，记录慕课网《JavaScript版数据结构与算法》教学视频。

## 基础概念

### 什么是数据结构与算法？

**数据结构：**计算机存储、组织数据的方式

**算法：**一系列解决问题的清晰指令

**程序：**数据结构 +  算法

数据够为算法提供服务，算法围绕数据结构操作。

**时间复杂度：**

一个函数，用大写O表示，比如 O(1)、O(n)、O(logN)，用来定性描述该算法的运行时间。

> 这里的 定性 只是用来表明大概所需时间趋势，而不是具体的时间

**举例：**

```
let i = 0
i += 1
```

> 上述代码复杂度为：O(1)，因为上述代码在执行时，只执行 1 次

```
for(let i = 0; i<n; i++){
    console.log(i)
}
```

> 上述代码复杂度为：O(n)，因为上述代码在执行时，执行 n 次

```
let i = 0
i += 1
for(let j = 0; j<n; j++){
    console.log(j)
}
```

> 上述代码复杂度为：O(n)，从代码字面上看复杂度应该为 O(1) + O(n)，但是如果 n 足够大时 +1 是可以被忽略不计的，因此上面代码的复杂度依然为看作 O(n)

```
for(let i = 0; i<n; i++){
  for(let j = 0; j<n; j++){
    console.log(i,j)
  }
}
```

> 上面代码复杂度为：O(n^2)，因为是嵌套 2 层循环，所以 复杂度为 O(n) * O(n)，即 n 的平方。

```
let i = 1
while(i<n){
  console.log(i)
  i *=2
}
```

> 上述代码复杂度为：O(logN)，因为在 while 中 每次 i * 2，所以实际执行次数，就应该是 logN。



**空间复杂度：**一个函数，用大写O表示，比如 O(1)、O(n)、O(logN)，用来描述算法在运行过程中临时占用存储空间大小的量度。

> 时间复杂度是来定量描述执行次数，而空间复杂度则是来描述 值 的数量

**举例：**

```
let i = 0
```

> 是需要记录一个值，因此上述代码空间复杂度为 O(1)

```
let arr = []
for(let i = 0; i<n; i++){
  arr.push[i]
}
```

> 使用 for 循环添加了 n 个元素，因此上述代码复杂度为 O(n)
> 实际上 arr 也是一个值，一个空间复杂度应该为 O(1) + O(n)，这里也采用时间复杂度的方式，将 +1 进行了忽略。



## 栈(stack)

### 栈的数据结构

**栈的数据结构为：数据后进先出**

> 在 JS 中没有 栈 的数据结构，但是 Array 完全可以模拟出 栈 结构，即使用 进 push()、出 pop()

### 栈的应用场景

**任何需要用到 后进先出 的场景**

1. 十进制转二进制
2. 判断字符串的括号是否有效
3. 函数调用堆栈(函数调用另外一个函数，代码逻辑执行的先后顺序，事实上是最后调用的函数，最先执行完成)
4. ...

**十进制转二进制：**

1. 将十进制数字 除以 2，若数字为 奇数 则 得数字 1、若数字为 偶数 则得数字 0
2. 若为 偶数 则得数字 0，并继续除以 2
3. 若为 奇数 则得数字 1， -1 后继续除以 2
4. 一直除到数字为 0 或 1，若得到数字 1 则得数字 0，若得到数字 0 则得数字 1
5. 最终将得到的 1 和 0 数字进行排序上的反转，即为 二进制数据

```
function getBinary(num: number): string {
    const arr: number[] = []

    while (num !== 0) {
        let now = num % 2
        arr.push(num % 2 ? 1 : 0)
        num = (num - now) / 2
    }
    //这里执行了 反转 数组，当然你也可以不在最后反转数组，而是在 while 循环中 不使用 push()，而是使用 unshift()
    arr.reverse()
    return arr.join('')
}

console.log(getBinary(35))
```

**判断字符串中的括号是否有效**

使用 栈 的思想来解决这个问题。

1. 新建一个 栈 用来暂存 符号
2. 假设循环遇到 {、[、( 则将该字符 push 添加到 栈中
3. 假设循环遇到 非 {、[、(  即 }、]、)，则将该字符串 与 栈中刚刚添加的字符串进行比较，若可以达成匹配则继续循环，若不能达成匹配则终止循环，并判定最终结果为 false

> 代码中关于是否 左侧符号，以及是否匹配，都采用 Map 实例中的属性来进行校验

```
function isValid(s: string): boolean {

    s = s.replace(' ', '')
    if (s === '' || s.length % 2) {
        return false
    }

    const map = new Map()
    map.set('{', '}')
    map.set('[', ']')
    map.set('(', ')')

    const stack: string[] = []
    let top: string

    for (let i = 0; i < s.length; i++) {
        top = s[i]
        if (map.get(top)) {
            stack.push(top)
        } else {
            if (stack.length === 0 || top !== map.get(stack.pop())) {
                return false
            }
        }
    }

    return stack.length === 0
}

console.log(isValid('{]'))
console.log(isValid('({})[{}]{}'))
console.log(isValid('([]{})'))
```



还有另外一个解决途径，不使用 栈 的思想，而是直接替换(消除)掉成对的字符串。

```
function isValid(s: string): boolean {
    s.replace(' ', '')

    if (s === '' || s.length % 2) {
        return false
    } else {
        let n = s.length / 2
        for (let i = 0; i < n; i++) {
            s = s.replace("{}", "")
            s = s.replace("[]", "")
            s = s.replace("()", "")
        }
    }
    return s.length === 0
}

console.log(isValid('{[({})]}'))
console.log(isValid('()[]{}'))
```

> 经过实际对比，虽然 第2种 解决方案 也可以，但是在性能方面低于 第1种 解决方案。